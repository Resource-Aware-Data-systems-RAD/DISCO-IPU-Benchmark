/* Copyright 2019-2021 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#ifndef LIBCORAL_CORAL_LEARN_IMPRINTING_ENGINE_H_
#define LIBCORAL_CORAL_LEARN_IMPRINTING_ENGINE_H_

#include <cstdint>
#include <memory>
#include <utility>
#include <vector>

#include "absl/status/status.h"
#include "absl/types/span.h"
#include "flatbuffers/flatbuffers.h"
#include "tensorflow/lite/schema/schema_generated.h"

namespace coral {

struct ImprintingClass {
  // Sum of the weights generated by imprinting extractor.
  std::vector<float> weights;
  // Indicates whether the weights can be updated or not.
  bool trainable;
};

class ImprintingModel {
 public:
  // Creates ImprintingModel instance from tflite::Model.
  static absl::Status Create(const tflite::Model& prototype,
                             std::unique_ptr<ImprintingModel>* out_model);

  // Creates ImprintingModel instance from tflite::Model or crashes on error.
  static std::unique_ptr<ImprintingModel> CreateOrDie(
      const tflite::Model& prototype);

  // Returns extractor model buffer by truncating the prototype model.
  absl::Span<const char> ExtractorModelBuffer() const {
    return absl::MakeSpan(
        reinterpret_cast<const char*>(extractor_fbb_.GetBufferPointer()),
        extractor_fbb_.GetSize());
  }

  // Returns classes from the prototype model.
  std::vector<ImprintingClass> LoadExistingClasses() const;

  // Serializes prototype model with the given array of classes.
  absl::Status SerializeModel(const std::vector<ImprintingClass>& classes,
                              flatbuffers::FlatBufferBuilder* fbb);

  // Returns embedding vector dimension.
  int embedding_dim() const { return embedding_dim_; }

 private:
  ImprintingModel() = default;

  std::unique_ptr<tflite::ModelT> model_t_;
  flatbuffers::FlatBufferBuilder extractor_fbb_;

  float fc_quant_scale_;
  int64_t fc_quant_zero_point_;

  int embedding_dim_;
};

// Class that implements `Imprinted Weights` transfer learning method proposed
// in paper https://arxiv.org/pdf/1712.07136.pdf.
class ImprintingEngine {
 public:
  ImprintingEngine(const ImprintingEngine&) = delete;
  ImprintingEngine& operator=(const ImprintingEngine&) = delete;

  // Validates input model and initializes `embedding_extractor`.
  //
  // The input model comes with L2Norm layer. It is supposed to be a full
  // classification model.
  //
  // Users can choose whether to keep previous classes by setting keep_classes
  // to true or false.
  //
  // Returns pair of EdgeTpuApiStatus and error message. Error message is only
  // relevant when status is not kEdgeTpuApiOk.
  static std::unique_ptr<ImprintingEngine> Create(
      std::unique_ptr<ImprintingModel> model, bool keep_classes);

  // Returns extractor model buffer.
  absl::Span<const char> ExtractorModelBuffer() const {
    return model_->ExtractorModelBuffer();
  }

  // Returns serialzied bytes of re-trained model. The model will contain:
  // [embedding_extractors] -> L2Norm -> Conv2d -> Mul -> Reshape -> Softmax
  absl::Status SerializeModel(flatbuffers::FlatBufferBuilder* fbb);

  // Trains the model with the given embedding vector of a certain category.
  //
  // Inputs: embedding vector
  //
  // If training a new category, the class id should be exactly of the next
  // class.
  //
  // If training existing category with more images, the imprinting engine must
  // be under keep_classes mode.
  //
  // Call this function multiple times to train multiple different categories.
  absl::Status Train(absl::Span<const float> embedding, int class_id);

  // Returns currently trained classes.
  const std::vector<ImprintingClass>& GetClasses() const { return classes_; }

  // Returns number of embedding dimenssions for each class.
  int embedding_dim() const { return model_->embedding_dim(); }

 private:
  explicit ImprintingEngine(std::unique_ptr<ImprintingModel> model)
      : model_(std::move(model)) {}

  std::unique_ptr<ImprintingModel> model_;
  std::vector<ImprintingClass> classes_;
};

}  // namespace coral

#endif  // LIBCORAL_CORAL_LEARN_IMPRINTING_ENGINE_H_
